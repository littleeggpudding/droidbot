import re
import functools
from datetime import datetime
import sys

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile('^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
                                  '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$')


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess
    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random
    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib
    return hashlib.md5(input_str.encode('utf-8')).hexdigest()

def generate_html_report(output_dir, replay_output_dir=None):
    """
    Generate a dual-column HTML report comparing record and replay actions
    
    :param output_dir: Directory containing record data (original test output)
    :param replay_output_dir: Directory containing replay data (optional)
    """
    import os
    import json
    import glob
    
    # Determine if this is a replay comparison
    is_replay_comparison = replay_output_dir is not None and os.path.exists(replay_output_dir)
    
    # Get event files
    if is_replay_comparison:
        record_events_dir = os.path.join(output_dir, "events")
        replay_events_dir = os.path.join(replay_output_dir, "events")
        
        record_event_files = sorted(glob.glob(os.path.join(record_events_dir, "event_*.json")))
        replay_event_files = sorted(glob.glob(os.path.join(replay_events_dir, "event_*.json")))
        
        # Get states directories
        record_states_dir = os.path.join(output_dir, "states")
        replay_states_dir = os.path.join(replay_output_dir, "states")
    else:
        record_events_dir = os.path.join(output_dir, "events")
        record_event_files = sorted(glob.glob(os.path.join(record_events_dir, "event_*.json")))
        record_states_dir = os.path.join(output_dir, "states")
        replay_event_files = []
        replay_states_dir = None
    
    # Load events
    record_events = []
    for event_file in record_event_files:
        try:
            with open(event_file, 'r') as f:
                event_data = json.load(f)
                record_events.append(event_data)
        except Exception as e:
            print(f"Error loading {event_file}: {e}")
    
    replay_events = []
    for event_file in replay_event_files:
        try:
            with open(event_file, 'r') as f:
                event_data = json.load(f)
                replay_events.append(event_data)
        except Exception as e:
            print(f"Error loading {event_file}: {e}")
    
    # Generate HTML
    html_content = generate_html_content(record_events, replay_events, 
                                       record_states_dir, replay_states_dir, 
                                       is_replay_comparison)
    
    # Save HTML file
    output_file = os.path.join(output_dir, "action_comparison_report.html")
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    print(f"HTML report generated: {output_file}")
    return output_file


def generate_html_content(record_events, replay_events, record_states_dir, replay_states_dir, is_replay_comparison):
    """Generate the HTML content for the comparison report"""
    
    # Get maximum number of events to compare
    max_events = max(len(record_events), len(replay_events))
    
    html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DroidBot Action Comparison Report</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .header {{
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }}
        .comparison-container {{
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }}
        .column {{
            flex: 1;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        .column-header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
        }}
        .action-item {{
            border-bottom: 1px solid #eee;
            padding: 15px;
            transition: background-color 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }}
        .action-item:hover {{
            background-color: #f8f9fa;
        }}
        .action-item:last-child {{
            border-bottom: none;
        }}
        .action-number {{
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            font-size: 14px;
        }}
        .action-type {{
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }}
        .action-details {{
            margin-left: 40px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }}
        .detail-row {{
            margin: 5px 0;
            font-size: 14px;
        }}
        .detail-label {{
            font-weight: 600;
            color: #666;
            display: inline-block;
            width: 120px;
        }}
        .detail-value {{
            color: #333;
            word-break: break-all;
        }}
        .no-data {{
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 40px;
        }}
        .screenshot {{
            max-width: 100%;
            # height: auto;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            height: 1200px;
        }}
        .no-screenshot {{
            background-color: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 5px;
            # padding: 20px;
            margin-top: 10px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            height: 1200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }}
        .event-type-touch {{ color: #28a745; }}
        .event-type-long_touch {{ color: #fd7e14; }}
        .event-type-scroll {{ color: #17a2b8; }}
        .event-type-intent {{ color: #6f42c1; }}
        .event-type-kill_app {{ color: #dc3545; }}
        .event-type-set_text {{ color: #20c997; }}
        .event-type-key {{ color: #e83e8c; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>DroidBot Action Comparison Report</h1>
        <p>{'Record vs Replay Comparison' if is_replay_comparison else 'Action Record Report'}</p>
        <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="comparison-container">
        <div class="column">
            <div class="column-header">
                {'Record Actions' if is_replay_comparison else 'Actions'}
            </div>
            <div class="column-content">
                {generate_actions_html(record_events, record_states_dir, 'record')}
            </div>
        </div>
        
        {f'''
        <div class="column">
            <div class="column-header">
                Replay Actions
            </div>
            <div class="column-content">
                {generate_actions_html(replay_events, replay_states_dir, 'replay')}
            </div>
        </div>
        ''' if is_replay_comparison else ''}
    </div>
</body>
</html>
"""
    return html


def create_annotated_screenshot(screenshot_path, view_data):
    """
    在截图上绘制bounds矩形标注
    """
    try:
        from PIL import Image, ImageDraw
        import os
        
        # 如果没有view_data或bounds，直接返回原图
        if not view_data or 'bounds' not in view_data:
            return screenshot_path
            
        bounds = view_data['bounds']
        if not bounds or len(bounds) != 2:
            return screenshot_path
            
        # 解析bounds坐标
        (x1, y1), (x2, y2) = bounds
        
        # 打开原图
        img = Image.open(screenshot_path)
        draw = ImageDraw.Draw(img)
        
        # 绘制矩形
        draw.rectangle([x1, y1, x2, y2], outline='red', width=3)
        
        # 生成新的文件名
        base_name = os.path.basename(screenshot_path)
        name, ext = os.path.splitext(base_name)
        annotated_name = f"{name}_annotated{ext}"
        annotated_path = os.path.join(os.path.dirname(screenshot_path), annotated_name)
        
        # 保存标注后的图片
        # 先创建目录 annotation_screenshots
        os.makedirs(f"{os.path.dirname(screenshot_path)}/annotation_screenshots/", exist_ok=True)
        annotated_path = os.path.join(f"{os.path.dirname(screenshot_path)}/annotation_screenshots/", annotated_name)
        img.save(annotated_path)
        
        return annotated_path
        
    except Exception as e:
        print(f"Error creating annotated screenshot: {e}")
        return screenshot_path


def generate_actions_html(events, states_dir, prefix):
    """Generate HTML for a list of actions"""
    import os
    import glob
    
    if not events:
        return '<div class="no-data">No actions recorded</div>'
    
    # Get sorted screenshot files (按文件名排序)
    screenshot_files = []
    if states_dir and os.path.exists(states_dir):
        # 先尝试PNG格式
        screenshot_files = sorted(glob.glob(os.path.join(states_dir, "screen_*.png")))
        # 如果PNG格式没有文件，再尝试JPG格式
        if not screenshot_files:
            screenshot_files = sorted(glob.glob(os.path.join(states_dir, "screen_*.jpg")))
    
    # 转换为绝对路径
    print(f"screenshot_files: {len(screenshot_files)}")
    
    expected_length = len(events) - 1  # 跳过第一个event
    if len(screenshot_files) < expected_length:
        # 在前面补None，保持长度一致
        none_count = expected_length - len(screenshot_files)
        screenshot_files = [None] * none_count + screenshot_files
    html_parts = []
    
    # 跳过第一个event（通常是KillAppEvent，没有对应的截图）
    filtered_events = events[1:] if len(events) > 1 else events

    # 如果是replay，并且screenshot_files比filtered_events多，则手动在尾部给events补None
    if prefix == 'replay' and len(filtered_events) < len(screenshot_files):
        filtered_events = filtered_events + [None] * (len(screenshot_files) - len(filtered_events))
    
    for i, event in enumerate(filtered_events):
        action_number = i + 1  # 从1开始计数，跳过第一个
        if event is not None:
            event_data = event.get('event', {})
        else:
            event_data = {}
        event_type = event_data.get('event_type', 'unknown')
        
        # 安全获取view字段，有些事件可能没有view
        view_data = event_data.get('view', {}) if 'view' in event_data else {}
        
        # Get screenshot if available (按索引一一对应，跳过第一个event)
        screenshot_html = ""
        if i < len(screenshot_files):
            screenshot_file = screenshot_files[i]
            if screenshot_file is not None:
                # 创建带标注的截图
                annotated_screenshot = create_annotated_screenshot(screenshot_file, view_data)
                screenshot_html = f'<img src="{annotated_screenshot}" class="screenshot" alt="Screenshot">'
            else:
                screenshot_html = '<div class="no-screenshot">No screenshot available</div>'
        
        # Extract view information (安全获取，避免KeyError)
        text = view_data.get('text', '') if view_data else 'N/A'
        resource_id = view_data.get('resource_id', '') if view_data else 'N/A'
        content_desc = view_data.get('content_description', '') if view_data else 'N/A'
        class_name = view_data.get('class', '') if view_data else 'N/A'
        
        # Format bounds (安全获取)
        bounds_str = 'N/A'
        if view_data:
            bounds = view_data.get('bounds', [])
            if bounds and len(bounds) == 2:
                x1, y1 = bounds[0]
                x2, y2 = bounds[1]
                bounds_str = f'({x1}, {y1}) - ({x2}, {y2})'
        
        html_parts.append(f"""
        <div class="action-item">
            <div class="action-type">
                <span class="action-number">{action_number}</span>
                <span class="event-type-{event_type}">{event_type.upper()}</span>
            </div>
            <div class="action-details">
                <div class="detail-row">
                    <span class="detail-label">Text:</span>
                    <span class="detail-value">{escape_html(text)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Resource ID:</span>
                    <span class="detail-value">{escape_html(resource_id)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Content Desc:</span>
                    <span class="detail-value">{escape_html(content_desc)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Class Name:</span>
                    <span class="detail-value">{escape_html(class_name)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Bounds:</span>
                    <span class="detail-value">{bounds_str}</span>
                </div>
                {screenshot_html}
            </div>
        </div>
        """)
    
    return ''.join(html_parts)


def escape_html(text):
    """Escape HTML special characters"""
    if not text:
        return 'N/A'
    return (str(text)
            .replace('&', '&amp;')
            .replace('<', '&lt;')
            .replace('>', '&gt;')
            .replace('"', '&quot;')
            .replace("'", '&#x27;'))

if __name__ == "__main__":
    generate_html_report("../test_output", "../replay_output_original")
